TypeScript Tutorial -https://www.w3schools.com/typescript/index.php

TypeScript is JavaScript with added syntax for types.

> > TypeScript Introduction

What is TypeScript? -------------------------------------------------------------------------------------- v --

TypeScript is a syntactic superset of JavaScript which adds static typing.
This basically means that TypeScript adds syntax on top of JavaScript, allowing developers to add types.

** TypeScript being a "Syntactic Superset" means that it shares the same base syntax as JavaScript, but adds something to it. **

Why should I use TypeScript? ----------------------------------------------------------------------------- v --

JavaScript is a loosely typed language. It can be difficult to understand what types of data are being passed around in JavaScript.
In JavaScript, function parameters and variables don't have any information! So developers need to look at documentation, or guess based on the implementation.
TypeScript allows specifying the types of data being passed around within the code, and has the ability to report errors when the types don't match.
For example, TypeScript will report an error when passing a string into a function that expects a number. JavaScript will not.

** TypeScript uses compile time type checking. Which means it checks if the specified types match before running the code, not while running the code. **

How do I use TypeScript? --------------------------------------------------------------------------------- v --

A common way to use TypeScript is to use the official TypeScript compiler, which transpiles TypeScript code into JavaScript.
The next section shows how to get the compiler setup for a local project.

Some popular code editors, such as Visual Studio Code, have built-in TypeScript support and can show errors as you write code!

TypeScript Exercises
TypeScript allows developers to add "types" to JavaScript.
JavaScript is a "losely" typed language.

> > TypeScript Getting Started

TypeScript Compiler -------------------------------------------------------------------------------------- v --

TypeScript is transpiled into JavaScript using a compiler.

** TypeScript being converted into JavaScript means it runs anywhere that JavaScript runs! **

Installing the Compiler ---------------------------------------------------------------------------------- v --

TypeScript has an official compiler which can be installed through npm.
Learn more about npm, and how to get started here: What is npm? "https://www.w3schools.com/whatis/whatis_npm.asp"

Within your npm project, run the following command to install the compiler:

npm install typescript --save-dev

Which should give you an output similar to:
added 1 package, and audited 2 packages in 2s
found 0 vulnerabilities

The compiler is installed in the node_modules directory and can be run with: npx tsc.
npx tsc

Which should give you an output similar to:
Version 4.5.5
tsc: The TypeScript Compiler - Version 4.5.5
Followed by a list of all the Common Commands.

Configuring the compiler ---------------------------------------------------------------------------------- v --

By default the TypeScript compiler will print a help message when run in an empty project.
The compiler can be configured using a tsconfig.json file.

You can have TypeScript create tsconfig.json with the recommended settings with:
npx tsc --init

Which should give you an output similar to:
Created a new tsconfig.json with:
TS
target: es2016
module: commonjs
strict: true
esModuleInterop: true
skipLibCheck: true
forceConsistentCasingInFileNames: true
You can learn more at https://aka.ms/tsconfig.json

Here is an example of more things you could add to the tsconfig.json file:
{
  "include": ["src"],
  "compilerOptions": {
    "outDir": "./build"
  }
}
You can open the file in an editor to add those options. This will configure the TypeScript compiler to transpile TypeScript files located in the src/ directory of your project, into JavaScript files in the build/ directory.

** This is one way to quickly get started with TypeScript. There are many other options available such as a create-react-app template, a node starter project, and a webpack plugin. **

Exercise:
The TypeScript compiler can be configured which file?
tsconfig.json

> > TypeScript Simple Types

TypeScript supports some simple types (primitives) you may know.

There are three main primitives in JavaScript and TypeScript.

boolean - true or false values
number - whole numbers and floating point values
string - text values like "TypeScript Rocks"
There are also 2 less common primitives used in later versions of Javascript and TypeScript.

bigint - whole numbers and floating point values, but allows larger negative and positive numbers than the number type.
symbol are used to create a globally unique identifier.

Type Assignment -------------------------------------------------------------------------------------------- v --

When creating a variable, there are two main ways TypeScript assigns a type:

> > > Explicit
> > > Implicit

Explicit Type -------- (_v_)
Explicit - writing out the type:

let firstName: string = "Dylan";
console.log(typeof firstName); // string

Explicit type assignment are easier to read and more intentional.

Implicit Type -------- (_v_)
Implicit - TypeScript will "guess" the type, based on the assigned value:

let firstName = "Dylan";
console.log(typeof firstName); // string

Note: Having TypeScript "guess" the type of a value is called infer.
Implicit assignment forces TypeScript to infer the value.
Implicit type assignment are shorter, faster to type, and often used when developing and testing.

Error In Type Assignment ------------------------------------------------------------------------------------ v --

TypeScript will throw an error if data types do not match.

Example
let firstName: string = "Dylan"; // type string
firstName = 33; // attempts to re-assign the value to a different type
console.log(firstName); // prog.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.

Implicit type assignment would have made firstName less noticeable as a string, but both will throw an error:

Example
let firstName = "Dylan"; // inferred to type string
firstName = 33; // attempts to re-assign the value to a different type
console.log(firstName); // prog.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.

JavaScript will not throw an error for mismatched types.

Unable to Infer ------------------------------------------------------------------------------------------- v --

TypeScript may not always properly infer what the type of a variable may be. In such cases, it will set the type to any which disables type checking.

Example
// Implicit any as JSON.parse doesn't know what type of data it returns so it can be "any" thing...
const json = JSON.parse("55");

// Most expect json to be an object, but it can be a string or a number like this example
console.log(typeof json); // number

This behavior can be disabled by enabling noImplicitAny as an option in a TypeScript's project tsconfig.json.
That is a JSON config file for customizing how some of TypeScript behaves.

Note: you may see primitive types capitalized like Boolean.
boolean !== Boolean
For this tutorial just know to use the lower-cased values, the upper-case ones are for very specific circumstances.

Exercise: ----------------(\v/)--
There are two main ways TypeScript assigns a type:
implicit
explicit

Create a "firstName" variable, string type using Implicit type:
let firstName = "Dylan"

Create a "firstName" variable, string type using Explicit type:
let firstName: string = "Dylan"

> > TypeScript Special Types

TypeScript has special types that may not refer to any specific type of data.

Type: any ------------------------------------------------------------------------------------------------ v --

any is a type that disables type checking and effectively allows all types to be used.

The example below does not use any and will throw an error:

Example without any -------- (_v_)
let u = true;
u = "string"; // Error: Type 'string' is not assignable to type 'boolean'.
Math.round(u); // Error: Argument of type 'boolean' is not assignable to parameter of type 'number'.

Setting any to the special type any disables type checking:

Example with any ----------- (_v_)
let v: any = true;
v = "string"; // no error as it can be "any" type
Math.round(v); // no error as it can be "any" type

Extra Examples +++

let u = true;
u = "string"; // Error: Type 'string' is not assignable to type 'boolean'.
u.runANonExistentMethod(); // Error: Property 'runANonExistentMethod' does not exist on type 'boolean'.
console.log(Math.round(u)); // Error: Argument of type 'boolean' is not assignable to parameter of type 'number'.
// Console :-
prog.ts(2,7): error TS2322: Type 'string' is not assignable to type 'boolean'.
prog.ts(3,9): error TS2339: Property 'runANonExistentMethod' does not exist on type 'boolean'.
prog.ts(4,18): error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'number'.

let v: any = true;
v = "string"; // no error as it can be "any" type
console.log(Math.round(v)); // no error as it can be "any" type
// Console :-
NaN

**----- any can be a useful way to get past errors since it disables type checking, but TypeScript will not be able provide type safety, and tools which rely on type data, such as auto completion, will not work. Remember, it should be avoided at "any" cost... -----**

Type: unknown --------------------------------------------------------------------------------------------- v --

unknown is a similar, but safer alternative to any.

TypeScript will prevent unknown types from being used, as shown in the below example:

let w: unknown = 1;
w = "string"; // no error

w = {
  runANonExistentMethod: () => {
    console.log("I think therefore I am");
  }
} as { runANonExistentMethod: () => void }

// How can we avoid the error for the code commented out below when we don't know the type?
// w.runANonExistentMethod(); // Error: Object is of type 'unknown'.

if(typeof w === 'object' && w !== null) {
(w as { runANonExistentMethod: Function }).runANonExistentMethod();
}
// Although we have to cast multiple times we can do a check in the if to secure our type and have a safer casting

// Console :-
I think therefore I am

Compare the example above to the previous example, with any.

**----- unknown is best used when you don't know the type of data being typed. To add a type later, you'll need to cast it. Casting is when we use the "as" keyword to say property or variable is of the casted type. -----**

Type: never ----------------------------------------------------------------------------------------------- v --

never effectively throws an error whenever it is defined.

let x: never = true; // Error: Type 'boolean' is not assignable to type 'never'.
Console :-
prog.ts(1,5): error TS2322: Type 'boolean' is not assignable to type 'never'.

**----- never is rarely used, especially by itself, its primary use is in advanced generics. -----**

Type: undefined & null ------------------------------------------------------------------------------------ v --

undefined and null are types that refer to the JavaScript primitives undefined and null respectively.

let y: undefined = undefined;
console.log(typeof y);

let z: null = null;
console.log(typeof z);

// Console :-
undefined
object

**----- These types don't have much use unless strictNullChecks is enabled in the tsconfig.json file. -----**

Exercise: ----------------(\v/)--
Create an empty "myVar" variable, and disable type checking:
let myVar: any;

Create an empty "myVar" variable, and specify it should be an unknown type:
let myVar: unknown;

> > TypeScript Arrays \*\*\*\* --( Compiler : https://www.w3schools.com/typescript/trytypescript.php?filename=demo_editor )--

TypeScript has a specific syntax for typing arrays.

Read more about arrays in our JavaScript Array chapter. >> https://www.w3schools.com/js/js_arrays.asp

const names: string[] = [];
names.push("Dylan"); // no error
names.push(3); // Error: Argument of type 'number' is not assignable to parameter of type 'string'.
console.log(names);

Console :-
prog.ts(3,15): error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.

Readonly ------------------------------------------------------------------------------------------ v --
The readonly keyword can prevent arrays from being changed.

Example
const names: readonly string[] = ["Dylan"];
names.push("Jack"); // Error: Property 'push' does not exist on type 'readonly string[]'.
// try removing the readonly modifier and see if it works?
console.log(names);

Console :-
prog.ts(2,13): error TS2339: Property 'push' does not exist on type 'readonly string[]'.

Type Inference ------------------------------------------------------------------------------------ v --
TypeScript can infer the type of an array if it has values.

Example
const numbers = [1, 2, 3]; // inferred to type number[]
numbers.push(4); // no error
// comment line below out to see the successful assignment
numbers.push("2"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.
console.log(numbers);
let head: number = numbers[0]; // no error
console.log(head);

Console :-
prog.ts(4,20): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.

Exercise: ----------------(\v/)--
Prevent the array from being changed:
const names: readonly string[] = ["Dylan"];

> > TypeScript Tuples

Typed Arrays -------------------------------------------------------------------------------------- v --
A tuple is a typed array with a pre-defined length and types for each index.
Tuples are great because they allow each element in the array to be a known type of value.
To define a tuple, specify the type of each element in the array:

Example
// define our tuple
let ourTuple: [number, boolean, string];
// initialize correctly
ourTuple = [5, false, 'Coding God was here'];
console.log(ourTuple);

Console :-
[ 5, false, 'Coding God was here' ]

-- As you can see we have a number, boolean and a string. But what happens if we try to set them in the wrong order:

Example
// define our tuple
let ourTuple: [number, boolean, string];
// initialize incorrectly throws an error
ourTuple = [false, 'Coding God was mistaken', 5];
console.log(ourTuple);

Console :-
prog.ts(4,21): error TS2322: Type 'boolean' is not assignable to type 'number'.
prog.ts(4,28): error TS2322: Type 'string' is not assignable to type 'boolean'.
prog.ts(4,55): error TS2322: Type 'number' is not assignable to type 'string'.

**----- Even though we have a boolean, string, and number the order matters in our tuple and will throw an error. -----**

Readonly Tuple -------------------------------------------------------------------------------------- v --
A good practice is to make your tuple readonly.
Tuples only have strongly defined types for the initial values:

Example
// define our tuple
let ourTuple: [number, boolean, string];
// initialize correctly
ourTuple = [5, false, 'Coding God was here'];
// We have no type safety in our tuple for indexes 3+
ourTuple.push('Something new and wrong');
console.log(ourTuple);

Console :-
[ 5, false, 'Coding God was here', 'Something new and wrong' ]

-- You see the new valueTuples only have strongly defined types for the initial values:

Example
// define our tuple
let ourTuple: [number, boolean, string];
// initialize correctly
ourTuple = [5, false, 'Coding God was here'];
// We have no type safety in our tuple for indexes 3+
ourTuple.push('Something new and wrong');
// instead use our readonly tuple
const ourReadonlyTuple: readonly [number, boolean, string] = [5, true, 'The Real Coding God'];
// throws error as it is readonly.
ourReadonlyTuple.push('Coding God took a day off');

Console :-
prog.ts(4,18): error TS2339: Property 'push' does not exist on type 'readonly [number, boolean, string]'.

-- To learn more about access modifiers like readonly go to our section on them here: TypeScript Classes -https://www.w3schools.com/typescript/typescript_classes.php.

**----- If you have ever used React before you have worked with tuples more than likely. -----**
**----- useState returns a tuple of the value and a setter function. -----**
**----- const [firstName, setFirstName] = useState('Dylan') is a common example. -----**
**----- Because of the structure we know our first value in our list will be a certain value type in this case a string and the second value a function. -----**

Named Tuples ---------------------------------------------------------------------------------------- v --
Named tuples allow us to provide context for our values at each index.

Example
const graph: [x: number, y: number] = [55.2, 41.3];

**----- Named tuples provide more context for what our index values represent. -----**

Destructuring Tuples -------------------------------------------------------------------------------- v --
Since tuples are arrays we can also destructure them.

Example
const graph: [number, number] = [55.2, 41.3];
const [x, y] = graph;

-- To review destructuring check it out here. -https://www.w3schools.com/react/react_es6_destructuring.asp

Exercise:
The order of value types does not matter for Tuples:
False
Define ourTuple as string and boolean, in that order:
let ourTuple: [string, boolean];

> > TypeScript Object Types

TypeScript has a specific syntax for typing objects.

Read more about objects in our JavaScript Objects chapter. -https://www.w3schools.com/js/js_objects.asp

Example
const car: { type: string, model: string, year: number } = {
  type: "Toyota",
  model: "Corolla",
  year: 2009
};
console.log(car);

Console :-
{ type: 'Toyota', model: 'Corolla', year: 2009 }

**----- Object types like this can also be written separately, and even be reused, look at interfaces for more details. -----** >> https://www.w3schools.com/typescript/typescript_aliases_and_interfaces.php

Type Inference ------------------------------------------------------------------------------------- v --
TypeScript can infer the types of properties based on their values.

Example
const car = {
  type: "Toyota",
};
car.type = "Ford"; // no error
car.type = 2; // Error: Type 'number' is not assignable to type 'string'.
console.log(car);

Console :-
prog.ts(5,7): error TS2322: Type 'number' is not assignable to type 'string'.

Optional Properties -------------------------------------------------------------------------------- v --
Optional properties are properties that don't have to be defined in the object definition.

Example without an optional property
const car: { type: string, mileage: number } = { // Error: Property 'mileage' is missing in type '{ type: string; }' but required in type '{ type: string; mileage: number; }'.
  type: "Toyota",
};
car.mileage = 2000;

Example with an optional property
const car: { type: string, mileage?: number } = { // no error
  type: "Toyota"
};
car.mileage = 2000;
console.log(car);

Console :-
{ type: 'Toyota', mileage: 2000 }

Index Signatures ------------------------------------------------------------------------------------ v --
Index signatures can be used for objects without a defined list of properties.

Example
const nameAgeMap: { [index: string]: number } = {};
nameAgeMap.Jack = 25; // no error
nameAgeMap.Mark = "Fifty"; // Error: Type 'string' is not assignable to type 'number'.
console.log(nameAgeMap);

Console :-
prog.ts(3,7): error TS2322: Type 'string' is not assignable to type 'number'.

**----- Index signatures like this one can also be expressed with utility types like Record<string, number>. -----**

// Learn more about utility types like this in our TypeScript Utility Types chapter.

Exercise
Add the correct types for the object below:

const car: { type: string, model: string, year: number } = {
  type: "Toyota",
  model: "Corolla",
  year: 2009
};

Specify that the second property, called model, should be optional:
const car: { type: string, model?: string } = {
  type: "Toyota"
};

> > TypeScript Enums

An enum is a special "class" that represents a group of constants (unchangeable variables).
Enums come in two flavors string and numeric. Lets start with numeric.

Numeric Enums - Default -------------------------------------------------------------------------------v--
By default, enums will initialize the first value to 0 and add 1 to each additional value:

Example
enum CardinalDirections {
  North,
  East,
  South,
  West
};  
let currentDirection = CardinalDirections.North;
// North is the first value so it logs '0'
console.log(currentDirection);
// throws error when commented in as 'North' is not a valid enum
// currentDirection = 'North';
// Error: "North" is not assignable to type 'CardinalDirections'.

Console :-
0

Numeric Enums - Initialized ----------------------------------------------------------------------------v--
You can set the value of the first numeric enum and have it auto increment from that:

Example
enum CardinalDirections {
  North = 1,
  East,
  South,
  West
};
// logs 1 since we initialized the first value to something other than '0'
console.log(CardinalDirections.North);
// logs 4 as it continued on from the initial '1' value
console.log(CardinalDirections.West);

Console :-
1
4

Numeric Enums - Fully Initialized ----------------------------------------------------------------------v--
You can assign unique number values for each enum value. Then the values will not incremented automatically:

Example
enum StatusCodes {
  NotFound = 404,
  Success = 200,
  Accepted = 202,
  BadRequest = 400
};
// logs 404
console.log(StatusCodes.NotFound);
// logs 200
console.log(StatusCodes.Success);

Console :-
404
200

String Enums -------------------------------------------------------------------------------------------v--
Enums can also contain strings. This is more common than numeric enums, because of their readability and intent.

Example
enum CardinalDirections {
  North = "North",
  East = "East",
  South = "South",
  West = "West"
};
// logs "North"
console.log(CardinalDirections.North);
// logs "West"
console.log(CardinalDirections.West);

Console :-
North
West

**----- Technically, you can mix and match string and numeric enum values, but it is recommended not to do so. -----**

Exercise
Create an enum called myEnum, with 2 constants (myFirstConst, mySecondConst) with default values:

enum myEnum {
  myFirstConst,
  mySecondConst
};

Create an enum called myEnum, with 2 constants (myFirstConst, mySecondConst) with the string values "first" and "second":

enum myEnum {
  myFirstConst = "first",
  mySecondConst = "second",
};

> >  TypeScript Type Aliases and Interfaces

TypeScript allows types to be defined separately from the variables that use them.
Aliases and Interfaces allows types to be easily shared between different variables/objects.

Type Aliases -------------------------------------------------------------------------------------------v--
Type Aliases allow defining types with a custom name (an Alias).
Type Aliases can be used for primitives like string or more complex types such as objects and arrays:

Example
// Try creating a new Car using the alias provided
type CarYear = number;
type CarType = string;
type CarModel = string;
type Car = {
  year: CarYear,
  type: CarType,
  model: CarModel
};

const carYear: CarYear = 2001
const carType: CarType = "Toyota"
const carModel: CarModel = "Corolla"
const car: Car = {
  year: carYear,
  type: carType,
  model: carModel
};

console.log(car);

Console :-
{ year: 2001, type: 'Toyota', model: 'Corolla' }

Interfaces --------------------------------------------------------------------------------------------v--
Interfaces are similar to type aliases, except they only apply to object types.

Example
// Try creating a new interface using it below
interface Rectangle {
  height: number,
  width: number
};

const rectangle: Rectangle = {
  height: 20,
  width: 10
};

console.log(rectangle);

Console :-
{ height: 20, width: 10 }

Extending Interfaces ----------------------------------------------------------------------------------v--
Interfaces can extend each other's definition.

**----- Extending an interface means you are creating a new interface with the same properties as the original, plus something new. -----**

Example
// Try creating a new interface and extending it like below
interface Rectangle {
  height: number,
  width: number
}

interface ColoredRectangle extends Rectangle {
  color: string
}

const coloredRectangle: ColoredRectangle = {
  height: 20,
  width: 10,
  color: "red"
};

console.log(coloredRectangle);

Console :-
{ height: 20, width: 10, color: 'red' }

Exercise

Create a Type Alias for a string, called carType:
type carType = string

Create an interface called myInterface, with the property myProp as a string:
interface myInterface {
  myProp :string
}

Extend the myInterface interface from last exercise, and add a property myExtProp as a number:
interface myExtInterface extends myInterface {
  myExtProp :number
}

> > TypeScript Union Types
Union types are used when a value can be more than a single type.
Such as when a property would be string or number.

Union | (OR) ----------------------------------------------------------------------------------v--
Using the | we are saying our parameter is a string or number:

Example
function printStatusCode(code: string | number) {
  console.log(`My status code is ${code}.`)
}
printStatusCode(404);
printStatusCode('404');

Console :-
My status code is 404.
My status code is 404.

Union Type Errors -----------------------------------------------------------------------------v--
Note: you need to know what your type is when union types are being used to avoid type errors:

Example
function printStatusCode(code: string | number) {
  console.log(`My status code is ${code.toUpperCase()}.`) // error: Property 'toUpperCase' does not exist on type 'string | number'. Property 'toUpperCase' does not exist on type 'number'
}
Console :-
prog.ts(2,51): error TS2339: Property 'toUpperCase' does not exist on type 'string | number'.
  Property 'toUpperCase' does not exist on type 'number'.

In our example we are having an issue invoking toUpperCase() as its a string method and number doesn't have access to it.

Exercise
Specify that the parameter "myVar" for the function can be either string or number:

function myFunc(myVar: string | number) {
  console.log(myVar)
}

> > TypeScript Functions

TypeScript has a specific syntax for typing function parameters and return values.
Read more about functions here -https://www.w3schools.com/js/js_functions.asp

Return Type -----------------------------------------------------------------------------v--

The type of the value returned by the function can be explicitly defined.

Example
// the `: number` here specifies that this function returns a number
function getTime(): number {
  return new Date().getTime();
}
console.log(getTime());

Console :-
1648464745471

**----- If no return type is defined, TypeScript will attempt to infer it through the types of the variables or expressions returned. -----**

Void Return Type -----------------------------------------------------------------------v--

The type void can be used to indicate a function doesn't return any value.

Example
function printHello(): void {
  console.log('Hello!');
}
printHello();

Console :-
Hello!

Parameters ------------------------------------------------------------------------------v--
Function parameters are typed with a similar syntax as variable declarations.

Example
function multiply(a: number, b: number) {
  return a * b;
}
console.log(multiply(2,5))

Console :-
10

**----- If no parameter type is defined, TypeScript will default to using any, unless additional type information is available as shown in the Default Parameters and Type Alias sections below. -----**

Optional Parameters ---------------------------------------------------------------------v--
By default TypeScript will assume all parameters are required, but they can be explicitly marked as optional.

Example
// the `?` operator here marks parameter `c` as optional
function add(a: number, b: number, c?: number) {
  return a + b + (c || 0);
}
console.log(add(2,5))

Console :-
7

Default Parameters ----------------------------------------------------------------------v--
For parameters with default values, the default value goes after the type annotation:

Example
function pow(value: number, exponent: number = 10) {
  return value ** exponent;
}
console.log(pow(10));

Console :-
10000000000

TypeScript can also infer the type from the default value.

Named Parameters ------------------------------------------------------------------------v--
Typing named parameters follows the same pattern as typing normal parameters.

Example
function divide({ dividend, divisor }: { dividend: number, divisor: number }) {
  return dividend / divisor;
}
console.log(divide({dividend: 10, divisor: 2}));

Console :-
5

Rest Parameters ------------------------------------------------------------------------v--
Rest parameters can be typed like normal parameters, but the type must be an array as rest parameters are always arrays.

Example
function add(a: number, b: number, ...rest: number[]) {
  return a + b + rest.reduce((p, c) => p + c, 0);
}
console.log(add(10,10,10,10,10));

Console :-
50

Type Alias -----------------------------------------------------------------------------v--
Function types can be specified separately from functions with type aliases.
These types are written similarly to arrow functions, read more about arrow functions here.
- https://www.w3schools.com/js/js_arrow_function.asp

Example
type Negate = (value: number) => number;
// in this function, the parameter `value` automatically gets assigned the type `number` from the type `Negate`
const negateFunction: Negate = (value) => value * -1;
console.log(negateFunction(10));

Console :-
-10

Exercise
Create a function that returns the string "Learning is Fun!", with the return type explicitly defined:
function myFunc(): string {
 return "Learning is Fun!";
}

Create a function that specifically does not return a value:
function myFunc(): void {
 return "Learning is Fun!";
}

Create a function with 2 parameters (myVar1 and myVar2), that are both strings:
function myFunc(myVar1 :string, myVar2:string) {
  return(myVar1 + myVar2);
}

Create a function with 2 parameters (myVar1 and myVar2,in that order), that are both strings.
Specify that myVar2 should be optional:
function myFunc(myVar1 :string, myVar2? :string) {
  return(myVar1 + (myVar2 || ""));
}

> > TypeScript Casting